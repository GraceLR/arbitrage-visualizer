/// <reference types="node" />
import { Writable } from 'stream';
import { postgresqlErrorCodes } from './errors';
import { Query } from './query';
import { SecureContextOptions } from 'tls';
import { Result as _Result, ResultIterator as _ResultIterator, ResultRow as _ResultRow } from './result';
import { DatabaseError, ErrorLevel, TransactionStatus } from './protocol';
import { DataFormat, DataType, Value, ValueTypeReader } from './types';
export declare type Result = _Result<Value>;
export declare type ResultIterator = _ResultIterator<Value>;
export declare type ResultRow = _ResultRow<Value>;
export declare type Connect = (Error | string | null);
export declare type End = void;
export interface Parameter {
    name: string;
    value: string;
}
export interface ClientNotice extends DatabaseError {
    level: ErrorLevel;
    code: keyof typeof postgresqlErrorCodes;
    message: string;
}
export interface DataTypeError {
    dataType: DataType;
    value: Value;
}
export declare const enum SSLMode {
    Disable = "disable",
    Prefer = "prefer",
    Require = "require",
    VerifyCA = "verify-ca"
}
export interface SSL {
    mode?: (SSLMode.Prefer | SSLMode.Require | SSLMode.VerifyCA);
    options?: SecureContextOptions;
}
export interface Configuration {
    host?: string;
    port?: number;
    user?: string;
    database?: string;
    password?: string;
    types?: Map<DataType, ValueTypeReader>;
    extraFloatDigits?: number;
    keepAlive?: boolean;
    preparedStatementPrefix?: string;
    connectionTimeout?: number;
    ssl?: (SSLMode.Disable | SSL);
}
export interface Notification {
    processId: number;
    channel: string;
    payload?: string;
}
export interface PreparedStatement {
    close: (portal?: string) => Promise<void>;
    execute: (values?: Value[], portal?: string, format?: DataFormat | DataFormat[], streams?: Record<string, Writable>) => ResultIterator;
}
declare type Callback<T> = (data: T) => void;
export declare class Client {
    readonly config: Configuration;
    private readonly events;
    private ending;
    private connected;
    private connecting;
    private error;
    private readonly encoding;
    private readonly writer;
    private readonly clientNonce;
    private serverSignature;
    private expect;
    private stream;
    private mustDrain;
    private activeRow;
    private bindQueue;
    private closeHandlerQueue;
    private cleanupQueue;
    private errorHandlerQueue;
    private preFlightQueue;
    private rowDescriptionQueue;
    private parameterDescriptionQueue;
    private nextPreparedStatementId;
    private activeDataHandlerInfo;
    closed: boolean;
    processId: number | null;
    secretKey: number | null;
    transactionStatus: TransactionStatus | null;
    constructor(config?: Configuration);
    private startup;
    private listen;
    connect(): Promise<void>;
    end(): Promise<void>;
    on(event: 'connect', callback: Callback<Connect>): void;
    on(event: 'end', callback: Callback<End>): void;
    on(event: 'parameter', callback: Callback<Parameter>): void;
    on(event: 'notification', callback: Callback<Notification>): void;
    on(event: 'error', callback: Callback<DatabaseError>): void;
    on(event: 'notice', callback: Callback<ClientNotice>): void;
    prepare(text: string, name?: string, types?: DataType[]): Promise<PreparedStatement>;
    query(text: string, values?: Value[], types?: DataType[], format?: DataFormat | DataFormat[], streams?: Record<string, Writable>): ResultIterator;
    private bindAndExecute;
    execute(query: Query): ResultIterator;
    private send;
    private send2;
    private parseError;
    private receive;
}
export {};
