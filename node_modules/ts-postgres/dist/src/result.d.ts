import { DatabaseError } from './protocol';
declare type Resolution = null | string | Error | DatabaseError;
declare type Resolver = (resolution: Resolution) => void;
declare type ResultHandler = (resolve: Resolver) => void;
declare type Callback<T> = (item: T) => void;
export declare class ResultRow<T> {
    readonly names: string[];
    readonly data: T[];
    private readonly length;
    constructor(names: string[], data: T[]);
    get(name: string): T | undefined;
}
export declare class Result<T> {
    names: string[];
    rows: T[][];
    status: null | string;
    constructor(names: string[], rows: T[][], status: null | string);
    [Symbol.iterator](): Iterator<ResultRow<T>>;
}
export declare class ResultIterator<T> extends Promise<Result<T>> {
    private container;
    private subscribers;
    private done;
    rows: T[][] | null;
    names: string[] | null;
    constructor(container: T[][], executor: ResultHandler);
    first(): Promise<ResultRow<T> | undefined>;
    one(): Promise<ResultRow<T>>;
    notify(done: boolean, status?: (string | DatabaseError | Error)): void;
    [Symbol.asyncIterator](): AsyncIterator<ResultRow<T>>;
}
export declare type DataHandler<T> = Callback<T | Resolution>;
export declare type NameHandler = Callback<string[]>;
export declare function makeResult<T>(): {
    iterator: ResultIterator<T>;
    dataHandler: Callback<string | Error | DatabaseError | T[] | null>;
    nameHandler: (names: string[]) => void;
};
export {};
