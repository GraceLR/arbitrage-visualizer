/// <reference types="node" />
import { Socket } from 'net';
import { Writable } from 'stream';
import { postgresqlErrorCodes } from './errors';
import { DataFormat, DataType, Value, ValueTypeReader } from './types';
export declare const enum Command {
    Bind = 66,
    Close = 67,
    Describe = 68,
    End = 88,
    Execute = 69,
    Flush = 72,
    Parse = 80,
    Password = 112,
    Query = 81,
    Sync = 83,
    SASLResponse = 112
}
export declare enum ErrorLevel {
    error = "ERROR",
    fatal = "FATAL",
    panic = "PANIC"
}
export declare const enum Message {
    Authentication = 82,
    BackendKeyData = 75,
    BindComplete = 50,
    CloseComplete = 51,
    CommandComplete = 67,
    EmptyQueryResponse = 73,
    ErrorResponse = 69,
    NoData = 110,
    Notice = 78,
    NotificationResponse = 65,
    ParseComplete = 49,
    ParameterDescription = 116,
    ParameterStatus = 83,
    ReadyForQuery = 90,
    RowData = 68,
    RowDescription = 84
}
export declare const enum SSLResponseCode {
    Supported = 83,
    NotSupported = 78
}
export declare const enum TransactionStatus {
    Idle = 73,
    InTransaction = 84,
    InError = 69
}
export declare type SegmentValue = Buffer | BigInt | number | null | string;
export declare type Segment = [SegmentType, SegmentValue];
export declare const enum SegmentType {
    Buffer = 0,
    Float4 = 1,
    Float8 = 2,
    Int8 = 3,
    Int16BE = 4,
    Int32BE = 5,
    Int64BE = 6,
    UInt32BE = 7
}
export interface RowDescription {
    columns: Uint32Array;
    names: string[];
}
export interface StartupConfiguration {
    user: string;
    database: string;
    extraFloatDigits: number;
}
export declare class DatabaseError extends Error {
    level: ErrorLevel;
    code: keyof typeof postgresqlErrorCodes;
    message: string;
    constructor(level: ErrorLevel, code: keyof typeof postgresqlErrorCodes, message: string);
}
export declare type Receive = (buffer: Buffer, offset: number, size: number) => number;
export declare function readRowDescription(buffer: Buffer, start: number, types?: ReadonlyMap<DataType, ValueTypeReader>): {
    columns: Uint32Array;
    names: string[];
};
export declare function readRowData(buffer: Buffer, row: Array<Value>, columnSpecification: Uint32Array, encoding: BufferEncoding, types: ReadonlyMap<DataType, ValueTypeReader> | null, streams: ReadonlyArray<Writable | null> | null): number;
export declare function writeMessage(code: number | null, segments: Segment[]): Buffer;
export declare class Reader {
    private readonly buffer;
    private offset;
    constructor(buffer: Buffer, offset: number);
    readInt32BE(): number;
    readCString(encoding: BufferEncoding): string;
}
export declare class Writer {
    private readonly encoding;
    private outgoing;
    constructor(encoding: BufferEncoding);
    bind(name: string, portal: string, format?: DataFormat | DataFormat[], values?: Value[], types?: DataType[]): void;
    close(name: string, kind: 'S' | 'P'): void;
    describe(name: string, kind: 'S' | 'P'): void;
    execute(portal: string, limit?: number): void;
    end(): void;
    flush(): void;
    parse(name: string, text: string, types?: DataType[]): void;
    password(text: string): void;
    saslInitialResponse(mechanism: string, clientNonce: string): boolean;
    saslResponse(data: string, password: string, clientNonce: string): string;
    saslFinal(data: string, serverSignature: string): void;
    send(socket: Socket): boolean;
    startup(config: StartupConfiguration): void;
    startupSSL(): void;
    sync(): void;
    private enqueue;
}
