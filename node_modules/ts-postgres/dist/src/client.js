"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const crypto_1 = require("crypto");
const os_1 = require("os");
const net_1 = require("net");
const ts_typed_events_1 = require("ts-typed-events");
const defaults = require("./defaults");
const logger = require("./logging");
const queue_1 = require("./queue");
const query_1 = require("./query");
const tls_1 = require("tls");
const result_1 = require("./result");
const protocol_1 = require("./protocol");
const types_1 = require("./types");
const utils_1 = require("./utils");
class Client {
    constructor(config = {}) {
        this.config = config;
        this.events = ts_typed_events_1.events({
            connect: new ts_typed_events_1.Event(),
            end: new ts_typed_events_1.Event(),
            parameter: new ts_typed_events_1.Event(),
            error: new ts_typed_events_1.Event(),
            notice: new ts_typed_events_1.Event(),
            notification: new ts_typed_events_1.Event()
        });
        this.ending = false;
        this.connected = false;
        this.connecting = false;
        this.error = false;
        this.encoding = 'utf-8';
        this.clientNonce = crypto_1.randomBytes(18).toString('base64');
        this.serverSignature = null;
        this.expect = 5;
        this.stream = new net_1.Socket();
        this.mustDrain = false;
        this.activeRow = null;
        this.bindQueue = new queue_1.Queue();
        this.closeHandlerQueue = new queue_1.Queue();
        this.cleanupQueue = new queue_1.Queue();
        this.errorHandlerQueue = new queue_1.Queue();
        this.preFlightQueue = new queue_1.Queue();
        this.rowDescriptionQueue = new queue_1.Queue();
        this.parameterDescriptionQueue = new queue_1.Queue();
        this.nextPreparedStatementId = 0;
        this.activeDataHandlerInfo = null;
        this.closed = false;
        this.processId = null;
        this.secretKey = null;
        this.transactionStatus = null;
        this.writer = new protocol_1.Writer(this.encoding);
        this.stream.on('close', () => {
            this.connected = false;
            this.events.end.emit();
        });
        this.stream.on('connect', () => {
            const keepAlive = (typeof this.config.keepAlive === 'undefined') ?
                this.config.keepAlive : true;
            if (keepAlive) {
                this.stream.setKeepAlive(true);
            }
            this.closed = false;
            this.startup();
        });
        /* istanbul ignore next */
        this.stream.on('error', (error) => {
            if (this.connecting) {
                this.events.connect.emit(error);
            }
            else {
                // Don't raise ECONNRESET errors - they can & should be
                // ignored during disconnect.
                if (this.ending && error.errno ===
                    os_1.constants.errno.ECONNRESET)
                    return;
                this.events.end.emit();
            }
        });
        this.stream.on('finish', () => {
            this.closed = true;
        });
    }
    startup() {
        const writer = new protocol_1.Writer(this.encoding);
        const ssl = defaults.sslMode === "disable" /* Disable */ ? "disable" /* Disable */ :
            this.config.ssl || {
                mode: defaults.sslMode,
            };
        const settings = {
            user: this.config.user || defaults.user || '',
            database: this.config.database || defaults.database || '',
            extraFloatDigits: this.config.extraFloatDigits || 0
        };
        if (ssl !== "disable" /* Disable */) {
            writer.startupSSL();
            const abort = (error) => {
                this.events.connect.emit(error);
                this.end();
            };
            const startup = (stream) => {
                if (stream)
                    this.stream = stream;
                writer.startup(settings);
                this.listen();
                this.send2(writer);
            };
            const required = ssl.mode === "require" /* Require */ ||
                ssl.mode === "verify-ca" /* VerifyCA */;
            this.stream.once('data', (buffer) => {
                const code = buffer.readInt8(0);
                switch (code) {
                    // Server supports SSL connections, continue.
                    case 83 /* Supported */:
                        break;
                    // Server does not support SSL connections.
                    case 78 /* NotSupported */:
                        if (required) {
                            abort(new Error('Server does not support SSL connections'));
                        }
                        else {
                            startup();
                        }
                        return;
                    // Any other response byte, including 'E'
                    // (ErrorResponse) indicating a server error.
                    default:
                        abort(new Error('Error establishing an SSL connection'));
                        return;
                }
                const context = ssl.options ?
                    tls_1.createSecureContext(ssl.options) :
                    undefined;
                const options = {
                    socket: this.stream,
                    secureContext: context
                };
                const verify = ssl.mode == "verify-ca" /* VerifyCA */;
                const stream = tls_1.connect(options, () => {
                    if (verify && !stream.authorized) {
                        abort(stream.authorizationError);
                    }
                    else {
                        startup(stream);
                    }
                });
                stream.on('error', (error) => {
                    abort(error);
                });
            });
        }
        else {
            writer.startup(settings);
            this.listen();
        }
        this.send2(writer);
    }
    listen() {
        let buffer = null;
        let offset = 0;
        let remaining = 0;
        this.stream.on('data', (newBuffer) => {
            const length = newBuffer.length;
            const size = length + remaining;
            if (buffer && remaining) {
                const free = buffer.length - offset - remaining;
                let tail = offset + remaining;
                if (free < length) {
                    const tempBuf = Buffer.allocUnsafe(size);
                    buffer.copy(tempBuf, 0, offset, tail);
                    offset = 0;
                    buffer = tempBuf;
                    tail = remaining;
                }
                newBuffer.copy(buffer, tail, 0, length);
            }
            else {
                buffer = newBuffer;
                offset = 0;
            }
            try {
                const read = this.receive(buffer, offset, size);
                offset += read;
                remaining = size - read;
            }
            catch (error) {
                if (this.connecting) {
                    this.events.connect.emit(error);
                }
                logger.warn(error);
                this.stream.destroy();
            }
        });
        this.stream.on('drain', () => {
            this.mustDrain = false;
            this.writer.flush();
        });
    }
    connect() {
        if (this.connecting) {
            throw new Error('Already connecting');
        }
        if (this.error) {
            throw new Error('Can\'t connect in error state');
        }
        this.connecting = true;
        const timeout = this.config.connectionTimeout || defaults.connectionTimeout;
        let p = this.events.connect.once().then((error) => {
            if (!error)
                return;
            this.connecting = false;
            this.stream.destroy();
            throw error;
        });
        const port = this.config.port || defaults.port;
        const host = this.config.host || defaults.host;
        if (host.indexOf('/') === 0) {
            this.stream.connect(host + '/.s.PGSQL.' + port);
        }
        else {
            this.stream.connect(port, host);
        }
        if (typeof timeout !== "undefined") {
            p = Promise.race([
                p,
                new Promise((_, reject) => setTimeout(() => reject(new Error(`Timeout after ${timeout} ms`)), timeout)),
            ]);
        }
        return p;
    }
    end() {
        if (this.ending) {
            throw new Error('Already ending');
        }
        if (this.closed) {
            throw new Error('Connection already closed');
        }
        if (this.stream.destroyed) {
            throw new Error('Connection unexpectedly destroyed');
        }
        this.ending = true;
        if (this.connected) {
            this.writer.end();
            this.send();
            this.stream.end();
            this.mustDrain = false;
        }
        else {
            this.stream.destroy();
        }
        return this.events.end.once();
    }
    on(event, callback) {
        switch (event) {
            case 'connect': {
                this.events.connect.on(callback);
                break;
            }
            case 'end': {
                this.events.end.on(callback);
                break;
            }
            case 'error': {
                this.events.error.on(callback);
                break;
            }
            case 'notice': {
                this.events.notice.on(callback);
                break;
            }
            case 'notification': {
                this.events.notification.on(callback);
                break;
            }
            case 'parameter': {
                this.events.parameter.on(callback);
                break;
            }
        }
    }
    prepare(text, name, types) {
        const providedNameOrGenerated = name || ((this.config.preparedStatementPrefix ||
            defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
        return new Promise((resolve, reject) => {
            const errorHandler = (error) => reject(error);
            this.errorHandlerQueue.push(errorHandler);
            this.writer.parse(providedNameOrGenerated, text, types || []);
            this.writer.describe(providedNameOrGenerated, 'S');
            this.preFlightQueue.push({
                descriptionHandler: (description) => {
                    const types = this.parameterDescriptionQueue.shift();
                    this.cleanupQueue.expect(3 /* ParameterDescription */);
                    resolve({
                        close: () => {
                            return new Promise((resolve) => {
                                this.writer.close(providedNameOrGenerated, 'S');
                                this.closeHandlerQueue.push(resolve);
                                this.cleanupQueue.push(1 /* Close */);
                                this.writer.flush();
                                this.send();
                            });
                        },
                        execute: (values, portal, format, streams) => {
                            const result = result_1.makeResult();
                            result.nameHandler(description.names);
                            const info = {
                                handler: {
                                    callback: result.dataHandler,
                                    streams: streams || {},
                                },
                                description: description,
                            };
                            this.bindAndExecute(info, {
                                name: providedNameOrGenerated,
                                portal: portal || '',
                                format: format || types_1.DataFormat.Binary,
                                values: values || [],
                                close: false
                            }, types);
                            return result.iterator;
                        }
                    });
                },
                dataHandler: null,
                bind: null
            });
            this.writer.sync();
            this.cleanupQueue.push(4 /* PreFlight */);
            this.cleanupQueue.push(3 /* ParameterDescription */);
            this.cleanupQueue.push(2 /* ErrorHandler */);
            this.send();
        });
    }
    query(text, values, types, format, streams) {
        const query = (typeof text === 'string') ?
            new query_1.Query(text, values, {
                types: types,
                format: format,
                streams: streams,
            }) :
            text;
        return this.execute(query);
    }
    bindAndExecute(info, bind, types) {
        try {
            this.writer.bind(bind.name, bind.portal, bind.format, bind.values, types);
        }
        catch (error) {
            info.handler.callback(error);
            return;
        }
        this.bindQueue.push(info);
        this.writer.execute(bind.portal);
        this.cleanupQueue.push(0 /* Bind */);
        if (bind.close) {
            this.writer.close(bind.name, 'S');
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Close */);
        }
        this.writer.sync();
        this.errorHandlerQueue.push((error) => { info.handler.callback(error); });
        this.cleanupQueue.push(2 /* ErrorHandler */);
        this.send();
    }
    execute(query) {
        if (this.closed && !this.connecting) {
            throw new Error('Connection is closed.');
        }
        const text = query.text;
        const values = query.values || [];
        const options = query.options;
        const format = options ? options.format : undefined;
        const types = options ? options.types : undefined;
        const streams = options ? options.streams : undefined;
        const portal = (options ? options.portal : undefined) || '';
        const result = result_1.makeResult();
        const descriptionHandler = (description) => {
            result.nameHandler(description.names);
        };
        const dataHandler = {
            callback: result.dataHandler,
            streams: streams || {},
        };
        if (values && values.length) {
            const name = (options ? options.name : undefined) || ((this.config.preparedStatementPrefix ||
                defaults.preparedStatementPrefix) + (this.nextPreparedStatementId++));
            this.writer.parse(name, text, types || []);
            this.writer.describe(name, 'S');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: dataHandler,
                bind: {
                    name: name,
                    portal: portal,
                    format: format || types_1.DataFormat.Binary,
                    values: values,
                    close: true
                }
            });
            this.cleanupQueue.push(4 /* PreFlight */);
        }
        else {
            const name = (options ? options.name : undefined) || '';
            this.writer.parse(name, text);
            this.writer.bind(name, portal);
            this.bindQueue.push(null);
            this.writer.describe(portal, 'P');
            this.preFlightQueue.push({
                descriptionHandler: descriptionHandler,
                dataHandler: dataHandler,
                bind: null
            });
            this.writer.execute(portal);
            this.writer.close(name, 'S');
            this.cleanupQueue.push(0 /* Bind */);
            this.cleanupQueue.push(4 /* PreFlight */);
            this.closeHandlerQueue.push(null);
            this.cleanupQueue.push(1 /* Close */);
        }
        const stack = new Error().stack;
        this.errorHandlerQueue.push((error) => {
            if (stack !== undefined)
                error.stack = stack.replace(/(?<=^Error: )\n/, error.toString() + "\n");
            result.dataHandler(error);
        });
        this.cleanupQueue.push(2 /* ErrorHandler */);
        this.writer.sync();
        this.send();
        return result.iterator;
    }
    send() {
        // TODO refactor
        if (!this.connected && !this.ending)
            return;
        this.mustDrain = !this.writer.send(this.stream);
    }
    send2(writer) {
        if (this.mustDrain || !this.stream.writable)
            return;
        this.mustDrain = !writer.send(this.stream);
    }
    parseError(buffer) {
        let level = null;
        let code = null;
        let message = null;
        const length = buffer.length;
        let offset = 0;
        while (offset < length) {
            const next = buffer.indexOf(0, offset);
            if (next < 0)
                break;
            const value = buffer.slice(offset + 1, next).toString();
            switch (buffer[offset]) {
                case 0x53: {
                    if (level === null) {
                        level = value;
                    }
                    break;
                }
                case 0x56: {
                    level = value;
                    break;
                }
                case 0x43: {
                    code = value;
                    break;
                }
                case 0x4d: {
                    message = value;
                    break;
                }
                default:
                    break;
            }
            offset = next + 1;
        }
        if (level && code && message) {
            return new protocol_1.DatabaseError(level, code, message);
        }
        throw new Error('Unable to parse error message.');
    }
    receive(buffer, offset, size) {
        const types = this.config.types || null;
        let read = 0;
        while (size >= this.expect + read) {
            let frame = offset + read;
            let mtype = buffer.readInt8(frame);
            // Fast path: retrieve data rows.
            if (mtype === 68 /* RowData */) {
                const info = this.activeDataHandlerInfo;
                if (!info) {
                    throw new Error('No active data handler');
                }
                if (!info.description) {
                    throw new Error('No result type information');
                }
                const { handler: { streams, callback, }, description: { columns, names, } } = info;
                let row = this.activeRow;
                const hasStreams = Object.keys(streams).length > 0;
                const mappedStreams = hasStreams ? names.map(name => streams[name] || null) : null;
                while (true) {
                    mtype = buffer.readInt8(frame);
                    if (mtype !== 68 /* RowData */)
                        break;
                    const bytes = buffer.readInt32BE(frame + 1) + 1;
                    const start = frame + 5;
                    if (size < 11 + read) {
                        this.expect = 7;
                        this.activeRow = row;
                        return read;
                    }
                    if (row === null) {
                        const count = buffer.readInt16BE(start);
                        row = new Array(count);
                    }
                    const startRowData = start + 2;
                    const slice = buffer.slice(startRowData, bytes + read);
                    const end = protocol_1.readRowData(slice, row, columns, this.encoding, types, mappedStreams);
                    const remaining = bytes + read - size;
                    if (remaining <= 0) {
                        callback(row);
                        row = null;
                    }
                    else {
                        const offset = startRowData + end;
                        buffer.writeInt8(mtype, offset - 7);
                        buffer.writeInt32BE(bytes - end - 1, offset - 6);
                        buffer.writeInt16BE(row.length, offset - 2);
                        this.expect = 12;
                        this.activeRow = row;
                        return read + end;
                    }
                    // Keep track of how much data we've consumed.
                    frame += bytes;
                    // If the next message header doesn't fit, we
                    // break out and wait for more data to arrive.
                    if (size < frame + 5) {
                        this.activeRow = row;
                        this.expect = 5;
                        return read;
                    }
                    read += bytes;
                }
                this.activeRow = null;
            }
            const bytes = buffer.readInt32BE(frame + 1) + 1;
            const length = bytes - 5;
            if (size < bytes + read) {
                this.expect = bytes;
                break;
            }
            this.expect = 5;
            read += bytes;
            // This is the start offset of the message data.
            const start = frame + 5;
            switch (mtype) {
                case 82 /* Authentication */: {
                    const writer = new protocol_1.Writer(this.encoding);
                    const code = buffer.readInt32BE(start);
                    outer: 
                    /* istanbul ignore next */
                    switch (code) {
                        case 0: {
                            process.nextTick(() => {
                                this.events.connect.emit(null);
                            });
                            break;
                        }
                        case 3: {
                            const s = this.config.password || defaults.password || '';
                            writer.password(s);
                            break;
                        }
                        case 5: {
                            const { user = '', password = '' } = this.config;
                            const salt = buffer.slice(start + 4, start + 8);
                            const shadow = utils_1.md5(`${password || defaults.password}` +
                                `${user || defaults.user}`);
                            writer.password(`md5${utils_1.md5(shadow, salt)}`);
                            break;
                        }
                        case 10: {
                            const reader = new protocol_1.Reader(buffer, start + 4);
                            const mechanisms = [];
                            while (true) {
                                const mechanism = reader.readCString(this.encoding);
                                if (mechanism.length === 0)
                                    break;
                                if (writer.saslInitialResponse(mechanism, this.clientNonce))
                                    break outer;
                                mechanisms.push(mechanism);
                            }
                            throw new Error(`SASL authentication unsupported (mechanisms: ${mechanisms.join(', ')})`);
                        }
                        case 11: {
                            const data = buffer.slice(start + 4, start + length).toString("utf8");
                            const password = this.config.password || defaults.password || '';
                            this.serverSignature = writer.saslResponse(data, password, this.clientNonce);
                            break;
                        }
                        case 12: {
                            const data = buffer.slice(start + 4, start + length).toString("utf8");
                            if (!this.serverSignature)
                                throw new Error('Server signature missing');
                            writer.saslFinal(data, this.serverSignature);
                            break;
                        }
                        default:
                            throw new Error(`Unsupported authentication scheme: ${code}`);
                    }
                    this.send2(writer);
                    break;
                }
                case 75 /* BackendKeyData */: {
                    this.processId = buffer.readInt32BE(start);
                    this.secretKey = buffer.readInt32BE(start + 4);
                    break;
                }
                case 50 /* BindComplete */: {
                    const info = this.bindQueue.shift();
                    this.cleanupQueue.expect(0 /* Bind */);
                    if (info) {
                        this.activeDataHandlerInfo = info;
                    }
                    break;
                }
                case 110 /* NoData */: {
                    this.cleanupQueue.expect(4 /* PreFlight */);
                    const preflight = this.preFlightQueue.shift();
                    if (preflight.dataHandler) {
                        const info = {
                            handler: preflight.dataHandler,
                            description: null,
                        };
                        if (preflight.bind) {
                            this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                        }
                        else {
                            this.activeDataHandlerInfo = info;
                        }
                    }
                    else {
                        throw new Error('Data handler not set');
                    }
                    break;
                }
                case 73 /* EmptyQueryResponse */:
                case 67 /* CommandComplete */: {
                    const info = this.activeDataHandlerInfo;
                    if (info) {
                        const status = buffer.slice(start, start + length - 1).toString();
                        info.handler.callback(status || null);
                        this.activeDataHandlerInfo = null;
                    }
                    break;
                }
                case 51 /* CloseComplete */: {
                    const handler = this.closeHandlerQueue.shift();
                    this.cleanupQueue.expect(1 /* Close */);
                    if (handler) {
                        handler();
                    }
                    break;
                }
                case 69 /* ErrorResponse */: {
                    const error = this.parseError(buffer.slice(start, start + length));
                    if (this.connecting)
                        throw error;
                    this.events.error.emit(error);
                    loop: while (true) {
                        switch (this.cleanupQueue.shift()) {
                            case 0 /* Bind */: {
                                this.bindQueue.shift();
                                break;
                            }
                            case 1 /* Close */: {
                                this.closeHandlerQueue.shift();
                                break;
                            }
                            case 2 /* ErrorHandler */: {
                                const handler = this.errorHandlerQueue.shift();
                                handler(error);
                                this.error = true;
                                break loop;
                            }
                            case 3 /* ParameterDescription */: {
                                // This does not seem to ever happen!
                                this.parameterDescriptionQueue.shift();
                                break;
                            }
                            case 4 /* PreFlight */: {
                                this.preFlightQueue.shift();
                                break;
                            }
                            case 5 /* RowDescription */: {
                                this.rowDescriptionQueue.shift();
                                break;
                            }
                        }
                    }
                    break;
                }
                case 78 /* Notice */: {
                    const notice = this.parseError(buffer.slice(start, start + length));
                    this.events.notice.emit(notice);
                    break;
                }
                case 65 /* NotificationResponse */: {
                    const reader = new protocol_1.Reader(buffer, start);
                    const processId = reader.readInt32BE();
                    const channel = reader.readCString(this.encoding);
                    const payload = reader.readCString(this.encoding);
                    this.events.notification.emit({
                        processId: processId,
                        channel: channel,
                        payload: payload
                    });
                    break;
                }
                case 49 /* ParseComplete */: {
                    break;
                }
                case 116 /* ParameterDescription */: {
                    const length = buffer.readInt16BE(start);
                    const types = new Array(length);
                    for (let i = 0; i < length; i++) {
                        const offset = start + 2 + i * 4;
                        const dataType = buffer.readInt32BE(offset);
                        types[i] = dataType;
                    }
                    this.parameterDescriptionQueue.push(types);
                    break;
                }
                case 83 /* ParameterStatus */: {
                    const reader = new protocol_1.Reader(buffer, start);
                    const name = reader.readCString(this.encoding);
                    const value = reader.readCString(this.encoding);
                    this.events.parameter.emit({
                        name: name,
                        value: value
                    });
                    break;
                }
                case 90 /* ReadyForQuery */: {
                    if (this.error) {
                        this.error = false;
                    }
                    else if (this.connected) {
                        this.errorHandlerQueue.shift();
                        this.cleanupQueue.expect(2 /* ErrorHandler */);
                    }
                    else {
                        this.connecting = false;
                        this.connected = true;
                    }
                    const status = buffer.readInt8(start);
                    this.transactionStatus = status;
                    this.send();
                    break;
                }
                case 84 /* RowDescription */: {
                    this.cleanupQueue.expect(4 /* PreFlight */);
                    const preflight = this.preFlightQueue.shift();
                    const description = protocol_1.readRowDescription(buffer, start, this.config.types);
                    preflight.descriptionHandler(description);
                    if (preflight.dataHandler) {
                        const info = {
                            handler: preflight.dataHandler,
                            description: description,
                        };
                        if (preflight.bind) {
                            this.bindAndExecute(info, preflight.bind, this.parameterDescriptionQueue.shift());
                        }
                        else {
                            this.activeDataHandlerInfo = info;
                        }
                    }
                    break;
                }
                default: {
                    logger.warn(`Message not implemented: ${mtype}`);
                    break;
                }
            }
        }
        return read;
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map