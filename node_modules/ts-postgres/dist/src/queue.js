"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var _head, _tail, _capacityMask, _list;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
/** A double-ended queue. All queue operations are `O(1)`. */
class Queue {
    constructor() {
        _head.set(this, 0);
        _tail.set(this, 0);
        _capacityMask.set(this, 0b11);
        _list.set(this, new Array(__classPrivateFieldGet(this, _capacityMask) + 1));
    }
    /** Returns the capacity of the queue. That is, that of the inner buffer. */
    get capacity() {
        return __classPrivateFieldGet(this, _list).length;
    }
    /** Returns the current number of elements in the queue. */
    get length() {
        return __classPrivateFieldGet(this, _head) <= __classPrivateFieldGet(this, _tail)
            ? __classPrivateFieldGet(this, _tail) - __classPrivateFieldGet(this, _head)
            : __classPrivateFieldGet(this, _capacityMask) + 1 - (__classPrivateFieldGet(this, _head) - __classPrivateFieldGet(this, _tail));
    }
    /** Returns whether the deque is empty. */
    get empty() {
        return __classPrivateFieldGet(this, _head) === __classPrivateFieldGet(this, _tail);
    }
    /** Performs a "soft" clear. This does **not** reset capacity. */
    clear() {
        __classPrivateFieldSet(this, _head, __classPrivateFieldSet(this, _tail, 0));
    }
    /** Inserts item to first slot. Returns the new length of the deque. */
    unshift(item) {
        const len = __classPrivateFieldGet(this, _list).length;
        __classPrivateFieldSet(this, _head, (__classPrivateFieldGet(this, _head) - 1 + len) & __classPrivateFieldGet(this, _capacityMask));
        __classPrivateFieldGet(this, _list)[__classPrivateFieldGet(this, _head)] = item;
        if (__classPrivateFieldGet(this, _tail) === __classPrivateFieldGet(this, _head))
            this.growArray();
        if (__classPrivateFieldGet(this, _head) < __classPrivateFieldGet(this, _tail))
            return __classPrivateFieldGet(this, _tail) - __classPrivateFieldGet(this, _head);
        return __classPrivateFieldGet(this, _capacityMask) + 1 - (__classPrivateFieldGet(this, _head) - __classPrivateFieldGet(this, _tail));
    }
    /** Removes and returns the first element. */
    shift() {
        const item = this.shiftMaybe();
        if (item !== undefined)
            return item;
        throw new Error("Queue is empty");
    }
    /** Removes and returns the first element or undefined.  */
    shiftMaybe() {
        if (this.empty)
            return;
        const head = __classPrivateFieldGet(this, _head);
        const item = __classPrivateFieldGet(this, _list)[head];
        __classPrivateFieldGet(this, _list)[head] = undefined;
        __classPrivateFieldSet(this, _head, (head + 1) & __classPrivateFieldGet(this, _capacityMask));
        if (head < 2 && __classPrivateFieldGet(this, _tail) > 10000 && __classPrivateFieldGet(this, _tail) <= __classPrivateFieldGet(this, _list).length >>> 2)
            this.shrinkArray();
        return item;
    }
    expect(expected) {
        const item = this.shift();
        if (item === undefined || (expected !== undefined && expected !== item)) {
            throw new Error(`Unexpected item: ${item} !== ${expected}`);
        }
        return item;
    }
    /** Inserts item to the last slot. Returns the new length of the deque. */
    push(item) {
        const tail = __classPrivateFieldGet(this, _tail);
        __classPrivateFieldGet(this, _list)[tail] = item;
        __classPrivateFieldSet(this, _tail, (tail + 1) & __classPrivateFieldGet(this, _capacityMask));
        if (this.empty)
            this.growArray();
        if (__classPrivateFieldGet(this, _head) < __classPrivateFieldGet(this, _tail))
            return __classPrivateFieldGet(this, _tail) - __classPrivateFieldGet(this, _head);
        return __classPrivateFieldGet(this, _capacityMask) + 1 - (__classPrivateFieldGet(this, _head) - __classPrivateFieldGet(this, _tail));
    }
    /** Removes and returns the last element. */
    pop() {
        if (this.empty)
            return;
        const tail = __classPrivateFieldGet(this, _tail);
        const len = __classPrivateFieldGet(this, _list).length;
        __classPrivateFieldSet(this, _tail, (tail - 1 + len) & __classPrivateFieldGet(this, _capacityMask));
        const item = __classPrivateFieldGet(this, _list)[__classPrivateFieldGet(this, _tail)];
        __classPrivateFieldGet(this, _list)[__classPrivateFieldGet(this, _tail)] = undefined;
        if (__classPrivateFieldGet(this, _head) < 2 && tail > 10000 && tail <= len >>> 2)
            this.shrinkArray();
        return item;
    }
    /** View the item at the specific index (without removing). */
    at(index) {
        // Disallow out of bounds access
        const len = this.length;
        if (index >= len || index < -len)
            return;
        // Wrap-around index
        if (index < 0)
            index += len;
        index = (__classPrivateFieldGet(this, _head) + index) & __classPrivateFieldGet(this, _capacityMask);
        return __classPrivateFieldGet(this, _list)[index];
    }
    *[(_head = new WeakMap(), _tail = new WeakMap(), _capacityMask = new WeakMap(), _list = new WeakMap(), Symbol.iterator)]() {
        const head = __classPrivateFieldGet(this, _head);
        const tail = __classPrivateFieldGet(this, _tail);
        // Simply yield elements from left to right
        if (head <= tail) {
            for (let i = head; i < tail; ++i)
                yield __classPrivateFieldGet(this, _list)[i];
            return;
        }
        // Yield elements from the head to the end
        const capacity = this.capacity;
        for (let i = head; i < capacity; ++i)
            yield __classPrivateFieldGet(this, _list)[i];
        // Then, wrap around and yield elements from start to tail
        for (let i = 0; i < tail; ++i)
            yield __classPrivateFieldGet(this, _list)[i];
    }
    shrinkArray() {
        __classPrivateFieldGet(this, _list).length >>>= 1;
        __classPrivateFieldSet(this, _capacityMask, __classPrivateFieldGet(this, _capacityMask) >>> 1);
    }
    growArray() {
        // Perform rotate-left if necessary
        if (__classPrivateFieldGet(this, _head) > 0) {
            // Copy existing data from head to end
            const deleted = __classPrivateFieldGet(this, _list).splice(__classPrivateFieldGet(this, _head));
            // Then, plop all preceding elements after `deleted`
            deleted.push(...__classPrivateFieldGet(this, _list));
            // Shift pointers accordingly
            __classPrivateFieldSet(this, _tail, __classPrivateFieldGet(this, _tail) - __classPrivateFieldGet(this, _head));
            __classPrivateFieldSet(this, _head, 0);
            // Discard old array
            __classPrivateFieldSet(this, _list, deleted);
        }
        // Head is at 0 and array is now full,
        // therefore safe to extend
        __classPrivateFieldSet(this, _tail, __classPrivateFieldGet(this, _list).length);
        // Double the capacity
        __classPrivateFieldGet(this, _list).length *= 2;
        __classPrivateFieldSet(this, _capacityMask, (__classPrivateFieldGet(this, _capacityMask) << 1) | 1);
    }
}
exports.Queue = Queue;
//# sourceMappingURL=queue.js.map