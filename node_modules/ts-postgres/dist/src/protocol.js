"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Writer = exports.Reader = exports.writeMessage = exports.readRowData = exports.readRowDescription = exports.DatabaseError = exports.ErrorLevel = void 0;
const buffer_1 = require("./buffer");
const sasl_1 = require("./sasl");
const utils_1 = require("./utils");
const types_1 = require("./types");
const arrayMask = 1 << 31;
const readerMask = 1 << 29;
const infinity = Number('Infinity');
const timeshift = 946684800000;
const isUndefined = Object.is.bind(null, undefined);
var ErrorLevel;
(function (ErrorLevel) {
    ErrorLevel["error"] = "ERROR";
    ErrorLevel["fatal"] = "FATAL";
    ErrorLevel["panic"] = "PANIC";
})(ErrorLevel = exports.ErrorLevel || (exports.ErrorLevel = {}));
class DatabaseError extends Error {
    constructor(level, code, message) {
        super(message);
        this.level = level;
        this.code = code;
        this.message = message;
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            /* eslint-disable-next-line @typescript-eslint/no-explicit-any */
            this.__proto__ = actualProto;
        }
    }
}
exports.DatabaseError = DatabaseError;
const nullBuffer = Buffer.from('null');
function dateToStringUTC(date, includeTime) {
    const pad = (n, length) => n.toString().padStart(length, '0');
    const year = date.getUTCFullYear();
    const isBC = year < 0;
    let result = pad(isBC ? (1 - year) : year, 4) + '-' +
        pad(date.getUTCMonth() + 1, 2) + '-' +
        pad(date.getUTCDate(), 2);
    if (includeTime) {
        result +=
            'T' +
                pad(date.getUTCHours(), 2) + ':' +
                pad(date.getUTCMinutes(), 2) + ':' +
                pad(date.getUTCSeconds(), 2) + '.' +
                pad(date.getUTCMilliseconds(), 3) +
                '+00:00';
    }
    if (isBC) {
        result += ' BC';
    }
    return result;
}
function formatUuid(bytes) {
    const slice = (start, end) => {
        return bytes.slice(start, end).toString('hex');
    };
    return [
        slice(0, 4),
        slice(4, 6),
        slice(6, 8),
        slice(8, 10),
        slice(10, 16)
    ].join('-');
}
function parseUuid(uuid) {
    return Buffer.from(uuid.replace(/-/g, ''), 'hex');
}
function makeBuffer(s, encoding, nullTerminate = false) {
    return Buffer.from(nullTerminate ? s + '\0' : s, encoding);
}
function makeBufferSegment(s, encoding, nullTerminate = false) {
    return [0 /* Buffer */, makeBuffer(s, encoding, nullTerminate)];
}
function getSegmentSize(segment, value) {
    switch (segment) {
        case 0 /* Buffer */: {
            if (value instanceof Buffer) {
                return value.length;
            }
            else {
                break;
            }
        }
        case 6 /* Int64BE */:
        case 2 /* Float8 */: {
            return 8;
        }
        case 3 /* Int8 */: {
            return 1;
        }
        case 4 /* Int16BE */: {
            return 2;
        }
        case 1 /* Float4 */:
        case 5 /* Int32BE */:
        case 7 /* UInt32BE */: {
            return 4;
        }
    }
    return -1;
}
function getMessageSize(code, segments) {
    // Messages are composed of a one byte message code plus a
    // 32-bit message length.
    let size = 4 + (code ? 1 : 0);
    // Precompute total message size.
    const length = segments.length;
    for (let i = 0; i < length; i++) {
        const [segment, value] = segments[i];
        size += Math.max(getSegmentSize(segment, value), 0);
    }
    return size;
}
function readRowDescription(buffer, start, types) {
    let offset = start;
    const length = buffer.readInt16BE(offset);
    const columns = new Uint32Array(length);
    const names = new Array(length);
    offset += 2;
    let i = 0;
    while (i < length) {
        const j = buffer.indexOf('\0', offset);
        const name = buffer.slice(offset, j).toString();
        const dataType = buffer.readInt32BE(j + 7);
        const innerDataType = types_1.arrayDataTypeMapping.get(dataType);
        const isArray = (typeof innerDataType !== 'undefined');
        const typeReader = (types) ? types.get(dataType) : undefined;
        columns[i] =
            ((innerDataType || dataType))
                | ((isArray) ? arrayMask : 0)
                | (typeReader ? readerMask : 0);
        names[i] = name;
        i++;
        offset = j + 19;
    }
    return {
        columns: columns,
        names: names
    };
}
exports.readRowDescription = readRowDescription;
function readRowData(buffer, row, columnSpecification, encoding, types, streams) {
    const columns = row.length;
    const bufferLength = buffer.length;
    // Find the row index (i.e., column) that's undefined which is
    // where we start reading row data.
    let i = row.findIndex(isUndefined);
    let offset = 0;
    while (i < columns) {
        // Must have enough data available to read column size.
        const start = offset + 4;
        if (bufferLength < start)
            break;
        const j = i;
        i++;
        const length = buffer.readInt32BE(offset);
        // If the length is reported as -1, this means a NULL value.
        const dataLength = (length >= 0 ? length : 0);
        const end = start + dataLength;
        const remaining = end - bufferLength;
        const partial = remaining > 0;
        let value = null;
        if (start < end) {
            const spec = columnSpecification[j];
            let skip = false;
            if (streams !== null && spec === types_1.DataType.Bytea) {
                const stream = streams[j];
                if (stream !== null) {
                    const slice = buffer.slice(start, end);
                    const alloc = Buffer.allocUnsafe(slice.length);
                    slice.copy(alloc, 0, 0, slice.length);
                    stream.write(alloc);
                    buffer.writeInt32BE(length - alloc.length, bufferLength - 4);
                    if (partial) {
                        return bufferLength - 4;
                    }
                    skip = true;
                }
            }
            if (partial) {
                break;
            }
            if (!skip) {
                const dataType = spec &
                    ~arrayMask &
                    ~readerMask;
                const isArray = (spec & arrayMask) !== 0;
                const isReader = (spec & readerMask) !== 0;
                if (isReader) {
                    const reader = (types) ? types.get(dataType) : null;
                    if (reader) {
                        value = reader(buffer, start, end, types_1.DataFormat.Binary, encoding);
                    }
                }
                else {
                    const read = (t, start, end) => {
                        if (start === end)
                            return null;
                        /* Cutoff for system object OIDs;
                           see comments in src/include/access/transam.h

                           We do not support user object OIDs.
                        */
                        if (t >= types_1.DataType.MinUserOid)
                            return null;
                        switch (t) {
                            case types_1.DataType.Bool:
                                return (buffer[start] !== 0);
                            case types_1.DataType.Date: {
                                const n = buffer.readInt32BE(start);
                                if (n === 0x7fffffff)
                                    return infinity;
                                if (n === -0x80000000)
                                    return -infinity;
                                // Shift from 2000 to 1970 and fix units.
                                return new Date((n * 1000 * 86400) + timeshift);
                            }
                            case types_1.DataType.Timestamp:
                            case types_1.DataType.Timestamptz: {
                                const lo = buffer.readUInt32BE(start + 4);
                                const hi = buffer.readInt32BE(start);
                                if (lo === 0xffffffff &&
                                    hi === 0x7fffffff)
                                    return infinity;
                                if (lo === 0x00000000 &&
                                    hi === -0x80000000)
                                    return -infinity;
                                return new Date((lo + hi * 4294967296) / 1000 +
                                    timeshift);
                            }
                            case types_1.DataType.Int2:
                                return buffer.readInt16BE(start);
                            case types_1.DataType.Int4:
                            case types_1.DataType.Oid:
                                return buffer.readInt32BE(start);
                            case types_1.DataType.Int8:
                                return buffer.readBigInt64BE(start);
                            case types_1.DataType.Float4:
                                return buffer.readFloatBE(start);
                            case types_1.DataType.Float8:
                                return buffer.readDoubleBE(start);
                            case types_1.DataType.Bpchar:
                            case types_1.DataType.Char:
                            case types_1.DataType.Name:
                            case types_1.DataType.Text:
                            case types_1.DataType.Varchar:
                                return buffer.toString(encoding, start, end);
                            case types_1.DataType.Bytea:
                                const new_buffer = Buffer.allocUnsafe(end - start);
                                buffer.copy(new_buffer, 0, start, end);
                                return new_buffer;
                            case types_1.DataType.Jsonb:
                                if (buffer[start] === 1) {
                                    const jsonb = buffer.toString(encoding, start + 1, end);
                                    if (jsonb) {
                                        return JSON.parse(jsonb);
                                    }
                                }
                                break;
                            case types_1.DataType.Json:
                                const json = buffer.toString(encoding, start, end);
                                if (json) {
                                    return JSON.parse(json);
                                }
                                break;
                            case types_1.DataType.Point:
                                return {
                                    x: buffer.readDoubleBE(start),
                                    y: buffer.readDoubleBE(start + 8)
                                };
                            case types_1.DataType.Uuid:
                                return formatUuid(buffer.slice(start, end));
                        }
                        return null;
                    };
                    if (isArray) {
                        let offset = start;
                        const readArray = (size) => {
                            const array = new Array(size);
                            for (let j = 0; j < size; j++) {
                                const length = buffer.readInt32BE(offset);
                                offset += 4;
                                let value = null;
                                if (length >= 0) {
                                    const elementStart = offset;
                                    offset = elementStart + length;
                                    value = read(elementType, elementStart, offset);
                                }
                                array[j] = value;
                            }
                            return array;
                        };
                        const dimCount = buffer.readInt32BE(offset) - 1;
                        const elementType = buffer.readInt32BE(offset += 8);
                        offset += 4;
                        if (dimCount === 0) {
                            const size = buffer.readInt32BE(offset);
                            offset += 8;
                            value = readArray(size);
                        }
                        else {
                            const arrays = new Array(dimCount);
                            const dims = new Uint32Array(dimCount);
                            for (let j = 0; j < dimCount; j++) {
                                const size = buffer.readInt32BE(offset);
                                dims[j] = size;
                                offset += 8;
                            }
                            const size = buffer.readInt32BE(offset);
                            const counts = Uint32Array.from(dims);
                            const total = dims.reduce((a, b) => a * b);
                            offset += 8;
                            for (let l = 0; l < total; l++) {
                                let next = readArray(size);
                                for (let j = dimCount - 1; j >= 0; j--) {
                                    const count = counts[j];
                                    const dim = dims[j];
                                    const k = dim - count;
                                    const m = count - 1;
                                    if (k === 0) {
                                        arrays[j] = new Array(dim);
                                    }
                                    const array = arrays[j];
                                    array[k] = next;
                                    counts[j] = m || dims[j];
                                    if (m !== 0)
                                        break;
                                    next = array;
                                }
                            }
                            value = arrays[0];
                        }
                    }
                    else {
                        value = read(dataType, start, end);
                    }
                }
            }
        }
        row[j] = value;
        offset = end;
    }
    return offset;
}
exports.readRowData = readRowData;
function writeMessage(code, segments) {
    const size = getMessageSize(code, segments);
    const buffer = Buffer.allocUnsafe(size);
    writeMessageInto(code, segments, buffer);
    return buffer;
}
exports.writeMessage = writeMessage;
function writeMessageInto(code, segments, buffer) {
    let offset = 0;
    if (code)
        buffer[offset++] = code;
    buffer.writeInt32BE(buffer.length - (code ? 1 : 0), offset);
    offset += 4;
    const length = segments.length;
    for (let i = 0; i < length; i++) {
        const [segment, value] = segments[i];
        switch (segment) {
            case 0 /* Buffer */: {
                if (value instanceof Buffer) {
                    value.copy(buffer, offset);
                    offset += value.length;
                }
                break;
            }
            case 1 /* Float4 */: {
                const n = Number(value);
                buffer.writeFloatBE(n, offset);
                offset += 4;
                break;
            }
            case 2 /* Float8 */: {
                const n = Number(value);
                buffer.writeDoubleBE(n, offset);
                offset += 8;
                break;
            }
            case 3 /* Int8 */: {
                const n = Number(value);
                buffer.writeInt8(n, offset);
                offset += 1;
                break;
            }
            case 4 /* Int16BE */: {
                const n = Number(value);
                buffer.writeInt16BE(n, offset);
                offset += 2;
                break;
            }
            case 5 /* Int32BE */: {
                const n = Number(value);
                buffer.writeInt32BE(n, offset);
                offset += 4;
                break;
            }
            case 6 /* Int64BE */: {
                const n = value instanceof Buffer ? value.readBigInt64BE(0) : (typeof value === "bigint" ? value : BigInt(Number(value)));
                buffer.writeBigInt64BE(n, offset);
                offset += 8;
                break;
            }
            case 7 /* UInt32BE */: {
                const n = Number(value);
                buffer.writeUInt32BE(n, offset);
                offset += 4;
                break;
            }
        }
    }
}
class Reader {
    constructor(buffer, offset) {
        this.buffer = buffer;
        this.offset = offset;
    }
    readInt32BE() {
        const n = this.buffer.readInt32BE(this.offset);
        this.offset += 4;
        return n;
    }
    readCString(encoding) {
        const offset = this.offset;
        const i = this.buffer.indexOf(0, offset);
        const s = this.buffer.toString(encoding, offset, i);
        this.offset = i + 1;
        return s;
    }
}
exports.Reader = Reader;
class Writer {
    constructor(encoding) {
        this.encoding = encoding;
        this.outgoing = new buffer_1.ElasticBuffer(4096);
    }
    bind(name, portal, format = types_1.DataFormat.Binary, values = [], types = []) {
        // We silently ignore any mismatch here, assuming that the
        // query will fail and make the error evident.
        const length = Math.min(types.length, values.length);
        const segments = [
            makeBufferSegment(portal, this.encoding, true),
            makeBufferSegment(name, this.encoding, true),
            [4 /* Int16BE */, length]
        ];
        const getFormat = (typeof format === 'number') ?
            () => format :
            (i) => format[i];
        for (let i = 0; i < length; i++) {
            segments.push([4 /* Int16BE */, getFormat(i)]);
        }
        segments.push([4 /* Int16BE */, length]);
        const add = (message, value) => {
            segments.push([message, value]);
            return getSegmentSize(message, value);
        };
        const reserve = (message) => {
            const segment = [message, null];
            segments.push(segment);
            return (value) => {
                segment[1] = value;
            };
        };
        const addBinaryValue = (value, dataType) => {
            let size = -1;
            const setSize = reserve(5 /* Int32BE */);
            if (value === null) {
                setSize(-1);
                return 0;
            }
            switch (dataType) {
                case types_1.DataType.Bool: {
                    size = add(3 /* Int8 */, (value) ? 1 : 0);
                    break;
                }
                case types_1.DataType.Date: {
                    if (value === infinity) {
                        size = add(5 /* Int32BE */, 0x7fffffff);
                    }
                    else if (value === -infinity) {
                        size = add(5 /* Int32BE */, -0x80000000);
                    }
                    else if (value instanceof Date) {
                        size = add(5 /* Int32BE */, (value.getTime() - timeshift) /
                            (1000 * 86400));
                    }
                    break;
                }
                case types_1.DataType.Timestamp:
                case types_1.DataType.Timestamptz: {
                    if (value === infinity) {
                        size = utils_1.sum(add(7 /* UInt32BE */, 0x7fffffff), add(7 /* UInt32BE */, 0xffffffff));
                    }
                    else if (value === -infinity) {
                        size = utils_1.sum(add(7 /* UInt32BE */, 0x80000000), add(7 /* UInt32BE */, 0x00000000));
                    }
                    else if (value instanceof Date) {
                        const n = (value.getTime() - timeshift) * 1000;
                        const f = Math.floor(n / 4294967296);
                        const r = n - f * 4294967296;
                        size = utils_1.sum(add(5 /* Int32BE */, f), add(7 /* UInt32BE */, r));
                    }
                    break;
                }
                case types_1.DataType.Bpchar:
                case types_1.DataType.Bytea:
                case types_1.DataType.Char:
                case types_1.DataType.Name:
                case types_1.DataType.Text:
                case types_1.DataType.Varchar: {
                    if (value instanceof Buffer) {
                        size = add(0 /* Buffer */, value);
                    }
                    else {
                        const s = String(value);
                        size = add(0 /* Buffer */, makeBuffer(s, this.encoding));
                    }
                    break;
                }
                case types_1.DataType.Float4: {
                    size = add(1 /* Float4 */, Number(value));
                    break;
                }
                case types_1.DataType.Float8: {
                    size = add(2 /* Float8 */, Number(value));
                    break;
                }
                case types_1.DataType.Int2: {
                    size = add(4 /* Int16BE */, Number(value));
                    break;
                }
                case types_1.DataType.Int4:
                case types_1.DataType.Oid: {
                    size = add(5 /* Int32BE */, Number(value));
                    break;
                }
                case types_1.DataType.Int8: {
                    size = add(6 /* Int64BE */, value instanceof Buffer ? value.readBigInt64BE(0) : (typeof value === "bigint" ? value : Number(value)));
                    break;
                }
                case types_1.DataType.Point: {
                    if (types_1.isPoint(value)) {
                        size = utils_1.sum(add(2 /* Float8 */, value.x), add(2 /* Float8 */, value.y));
                    }
                    break;
                }
                case types_1.DataType.Jsonb:
                    const body = JSON.stringify(value);
                    add(3 /* Int8 */, 0x01);
                    size = 1 + add(0 /* Buffer */, makeBuffer(body, this.encoding));
                    break;
                case types_1.DataType.Json: {
                    const body = JSON.stringify(value);
                    size = add(0 /* Buffer */, makeBuffer(body, this.encoding));
                    break;
                }
                case types_1.DataType.Uuid: {
                    try {
                        if (typeof value === 'string') {
                            const buffer = parseUuid(value);
                            size = add(0 /* Buffer */, buffer);
                        }
                    }
                    catch (error) {
                        throw new Error(`Invalid UUID: ${value} (${error})`);
                    }
                    break;
                }
                default: {
                    const innerDataType = types_1.arrayDataTypeMapping.get(dataType);
                    if (innerDataType && value instanceof Array) {
                        size = addBinaryArray(value, innerDataType);
                    }
                    else {
                        throw new Error(`Unsupported data type: ${dataType}`);
                    }
                }
            }
            setSize(size);
            return size;
        };
        const addBinaryArray = (value, dataType) => {
            const setDimCount = reserve(5 /* Int32BE */);
            add(5 /* Int32BE */, 1);
            add(5 /* Int32BE */, dataType);
            let bytes = 12;
            let dimCount = 0;
            const go = (level, value) => {
                const length = value.length;
                if (length === 0)
                    return;
                if (level === dimCount) {
                    bytes += utils_1.sum(add(5 /* Int32BE */, length), add(5 /* Int32BE */, 1));
                    dimCount++;
                }
                for (let i = 0; i < length; i++) {
                    const v = value[i];
                    if (v instanceof Array) {
                        go(level + 1, v);
                    }
                    else {
                        bytes += addBinaryValue(v, dataType) + 4;
                    }
                }
            };
            go(0, value);
            setDimCount(dimCount);
            return bytes;
        };
        const getTextFromValue = (value, dataType) => {
            if (value === null)
                return null;
            switch (dataType) {
                case types_1.DataType.Bool:
                    return value ? 't' : 'f';
                case types_1.DataType.Int2:
                case types_1.DataType.Int4:
                case types_1.DataType.Int8:
                case types_1.DataType.Oid:
                case types_1.DataType.Float4:
                case types_1.DataType.Float8:
                    if (typeof value === 'number') {
                        return value.toString();
                    }
                    break;
                case types_1.DataType.Bpchar:
                case types_1.DataType.Bytea:
                case types_1.DataType.Char:
                case types_1.DataType.Name:
                case types_1.DataType.Text:
                case types_1.DataType.Varchar:
                    return (typeof value === 'string') ?
                        value :
                        (value instanceof Buffer) ?
                            value.toString(this.encoding) :
                            value.toString();
                case types_1.DataType.Date:
                    return (value instanceof Date) ?
                        dateToStringUTC(value, false) :
                        value.toString();
                case types_1.DataType.Timestamp:
                case types_1.DataType.Timestamptz:
                    return (value instanceof Date) ?
                        dateToStringUTC(value, true) :
                        value.toString();
                case types_1.DataType.Jsonb:
                case types_1.DataType.Json:
                    return JSON.stringify(value);
                default: {
                    const innerDataType = types_1.arrayDataTypeMapping.get(dataType);
                    if (innerDataType) {
                        if (value instanceof Array) {
                            return getTextFromArray(value, innerDataType);
                        }
                    }
                    throw new Error(`Unsupported data type: ${dataType}`);
                }
            }
            return null;
        };
        const getTextFromArray = (value, dataType) => {
            const strings = [];
            strings.push('{');
            const escape = (s) => {
                return s
                    .replace(/\\/gu, '\\\\')
                    .replace(/"/gu, '\\"')
                    .replace(/,/gu, '\\,');
            };
            for (let i = 0; i < value.length; i++) {
                if (i > 0)
                    strings.push(',');
                const child = value[i];
                const result = (child instanceof Array) ?
                    getTextFromArray(child, dataType) :
                    getTextFromValue(child, dataType);
                if (result instanceof Array) {
                    strings.push(...result);
                }
                else {
                    strings.push((result === null) ? 'null' : escape(result));
                }
            }
            strings.push('}');
            return strings;
        };
        for (let i = 0; i < length; i++) {
            const value = values[i];
            const dataType = types[i];
            const format = getFormat(i);
            if (format === types_1.DataFormat.Binary) {
                addBinaryValue(value, dataType);
            }
            else {
                const result = getTextFromValue(value, dataType);
                const setSize = reserve(5 /* Int32BE */);
                const size = (result instanceof Array) ?
                    utils_1.sum(...result.map((s) => add(0 /* Buffer */, makeBuffer(s, this.encoding)))) :
                    add(0 /* Buffer */, (result === null) ?
                        nullBuffer :
                        makeBuffer(result, this.encoding));
                setSize(size);
            }
        }
        add(4 /* Int16BE */, 1);
        add(4 /* Int16BE */, 1);
        this.enqueue(66 /* Bind */, segments);
    }
    close(name, kind) {
        this.enqueue(67 /* Close */, [
            makeBufferSegment(kind + name, this.encoding, true)
        ]);
    }
    describe(name, kind) {
        this.enqueue(68 /* Describe */, [
            makeBufferSegment(kind + name, this.encoding, true)
        ]);
    }
    execute(portal, limit = 0) {
        this.enqueue(69 /* Execute */, [
            makeBufferSegment(portal, this.encoding, true),
            [5 /* Int32BE */, limit],
        ]);
    }
    end() {
        this.enqueue(88 /* End */, []);
    }
    flush() {
        this.enqueue(72 /* Flush */, []);
    }
    parse(name, text, types = []) {
        const length = types.length;
        const segments = [
            makeBufferSegment(name, this.encoding, true),
            makeBufferSegment(text, this.encoding, true),
            [4 /* Int16BE */, length]
        ];
        for (let i = 0; i < length; i++) {
            segments.push([5 /* Int32BE */, types[i]]);
        }
        this.enqueue(80 /* Parse */, segments);
    }
    password(text) {
        this.enqueue(112 /* Password */, [makeBufferSegment(text, this.encoding, true)]);
    }
    saslInitialResponse(mechanism, clientNonce) {
        if (mechanism !== 'SCRAM-SHA-256')
            return false;
        const response = Buffer.from('n,,n=*,r=' + clientNonce);
        this.enqueue(112 /* SASLResponse */, [
            makeBufferSegment(mechanism, this.encoding, true),
            [5 /* Int32BE */, response.length],
            [0 /* Buffer */, response]
        ]);
        return true;
    }
    saslResponse(data, password, clientNonce) {
        const m = Object.fromEntries(data.split(',').map((attr) => [attr[0], attr.substring(2)]));
        if (!(m.i && m.r && m.s))
            throw new Error("SASL message parse error");
        const nonce = m.r;
        if (!nonce.startsWith(clientNonce))
            throw new Error("SASL nonce mismatch");
        if (nonce.length === clientNonce.length)
            throw new Error("SASL nonce too short");
        const iterations = parseInt(m.i, 10);
        const salt = Buffer.from(m.s, 'base64');
        const saltedPassword = sasl_1.hi(password, salt, iterations);
        const clientKey = sasl_1.hmacSha256(saltedPassword, 'Client Key');
        const storedKey = sasl_1.sha256(clientKey);
        const clientFinalMessageWithoutProof = 'c=biws,r=' + nonce;
        const clientFirstMessageBare = 'n=*,r=' + clientNonce;
        const serverFirstMessage = data;
        const authMessage = (clientFirstMessageBare + ',' +
            serverFirstMessage + ',' +
            clientFinalMessageWithoutProof);
        const clientSignature = sasl_1.hmacSha256(storedKey, authMessage);
        const clientProofBytes = sasl_1.xorBuffers(clientKey, clientSignature);
        const clientProof = clientProofBytes.toString('base64');
        const serverKey = sasl_1.hmacSha256(saltedPassword, 'Server Key');
        const serverSignatureBytes = sasl_1.hmacSha256(serverKey, authMessage);
        const response = clientFinalMessageWithoutProof + ',p=' + clientProof;
        const serverSignature = serverSignatureBytes.toString('base64');
        this.enqueue(112 /* SASLResponse */, [
            makeBufferSegment(response, this.encoding, false)
        ]);
        return serverSignature;
    }
    saslFinal(data, serverSignature) {
        if (!data.split(',').find((attr) => {
            if (attr[0] === 'v') {
                return (attr.substr(2) === serverSignature);
            }
            return false;
        }))
            throw new Error('SASL server signature does not match');
    }
    send(socket) {
        if (this.outgoing.empty)
            return false;
        const buffer = this.outgoing.consume();
        return socket.write(buffer);
    }
    startup(config) {
        const data = [
            'user',
            config.user,
            'database',
            config.database,
            'extra_float_digits',
            String(config.extraFloatDigits),
            'client_encoding',
            this.encoding,
            ''
        ];
        const segments = [
            [4 /* Int16BE */, 3],
            [4 /* Int16BE */, 0]
        ];
        for (const s of data) {
            segments.push(makeBufferSegment(s, this.encoding, true));
        }
        this.enqueue(null, segments);
    }
    startupSSL() {
        const segments = [
            [4 /* Int16BE */, 0x04D2],
            [4 /* Int16BE */, 0x162F]
        ];
        this.enqueue(null, segments);
    }
    sync() {
        this.enqueue(83 /* Sync */, []);
    }
    enqueue(code, segments) {
        const size = getMessageSize(code, segments);
        // Allocate space and write segments.
        const buffer = this.outgoing.getBuffer(size);
        writeMessageInto(code, segments, buffer);
    }
}
exports.Writer = Writer;
//# sourceMappingURL=protocol.js.map